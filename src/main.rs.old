#![feature(int_roundings)]

use std::{io::Write, net::TcpStream, time::Instant};

use byteorder::{BigEndian, WriteBytesExt};
extern crate pretty_env_logger;
#[macro_use]
extern crate log;
use net::{
    codec::{MinecraftCodec, RawPacket},
    packets::decode_packet,
};
use varint::WriteProtoExt;
use world::ChunkManager;

use crate::{
    fixed_point::FixedPoint, net::packets::encode_packet, render::chunk_mesher::mesh_chunk,
};

mod fixed_point;
mod net;
mod nibble_slice;
mod render;
mod varint;
mod world;

fn main() -> anyhow::Result<()> {
    pretty_env_logger::init();

    let mut conn = TcpStream::connect("localhost:25565")?;
    conn.set_read_timeout(None)?;
    conn.set_write_timeout(None)?;

    let mut handshake_packet = RawPacket {
        id: 0,
        data: vec![],
    };

    handshake_packet.data.write_varint(5)?;
    handshake_packet.data.write_varstring("localhost")?;
    handshake_packet.data.write_u16::<BigEndian>(25565)?;
    handshake_packet.data.write_varint(2)?;

    MinecraftCodec::write(&mut conn, &handshake_packet)?;

    let mut login_packet = RawPacket {
        id: 0,
        data: vec![],
    };

    login_packet.data.write_varstring("cohaereo")?;

    MinecraftCodec::write(&mut conn, &login_packet)?;

    let mut chunks = ChunkManager::new();

    // Wait for login success
    while MinecraftCodec::read(&mut conn)?.id != 2 {}

    'game: loop {
        let p = MinecraftCodec::read(&mut conn)?;
        match decode_packet(&p) {
            Ok(p) => {
                // debug!("Received packet: {:?}", p);

                match p {
                    net::packets::Packet::KeepAlive(t) => {
                        let mut rp = RawPacket {
                            id: 0,
                            data: vec![],
                        };

                        rp.data.write_i32::<BigEndian>(t)?;
                        MinecraftCodec::write(&mut conn, &rp)?;
                    }
                    net::packets::Packet::PlayerPositionLookServer {
                        x,
                        y,
                        z,
                        yaw,
                        pitch,
                        on_ground,
                    } => {
                        // println!("Writing response");
                        let rp = encode_packet(&net::packets::Packet::PlayerPositionLookClient {
                            x,
                            feet_y: y - 1.62,
                            head_y: y,
                            z,
                            yaw,
                            pitch,
                            on_ground,
                        })?;
                        MinecraftCodec::write(&mut conn, &rp)?;
                        let rp = encode_packet(&net::packets::Packet::ClientStatus(0))?;
                        MinecraftCodec::write(&mut conn, &rp)?;
                    }
                    net::packets::Packet::ChatMessage(s) => {
                        info!("Chat message: {}", s);
                    }
                    net::packets::Packet::SpawnMob {
                        eid,
                        mobtype,
                        x,
                        y,
                        z,
                        yaw,
                        pitch,
                        head_pitch,
                        velocity_x,
                        velocity_y,
                        velocity_z,
                    } => {
                        let rp = encode_packet(&net::packets::Packet::ChatMessage(format!(
                            "SpawnMob {{ x={}, y={}, z={}, type={} }}",
                            x, y, z, mobtype
                        )))?;

                        MinecraftCodec::write(&mut conn, &rp)?;
                    }
                    net::packets::Packet::MapChunkBulk {
                        columns,
                        has_sky_light,
                        data,
                        meta,
                    } => {
                        println!("Received {} chunks", columns);
                        let mut data_offset = 0;
                        for (i, cm) in meta.iter().enumerate() {
                            let bytes_read = chunks.load_chunk(
                                (cm.chunk_x, cm.chunk_z),
                                cm.primary_bitmap,
                                cm.add_bitmap,
                                has_sky_light,
                                true,
                                &data[data_offset..],
                            )?;

                            data_offset += bytes_read as usize;
                        }

                        if data_offset < data.len() {
                            warn!("Trailing data in chunk batch!");
                        }

                        // panic!("Stopping at first chunk batch");
                    }
                    net::packets::Packet::Disconnect(reason) => {
                        warn!("Disconnected: {}", reason);
                        break 'game;
                    }
                    _ => {}
                }
            }
            Err(e) => error!("Error decoding packet: {}", e),
        }
        // info!("0x{:x} {} bytes", response.id, response.data.len());
    }

    let mut objf = std::fs::File::create("World.obj")?;
    objf.write(b"o World\n")?;

    let mut v = Vec::new();
    let mut total_time_meshing = 0f64;
    let mut base_index = 1;
    for (i, (coord, c)) in chunks.chunks.iter().enumerate() {
        println!("Chunk {}/{}", i, chunks.chunks.len());
        let base = (coord.0 as f32 * 16.0, coord.1 as f32 * 16.0);
        let mstart = Instant::now();
        let (vertices, indices) = mesh_chunk(c);
        let mend = Instant::now();
        println!(
            "Meshing took {}ms",
            mend.duration_since(mstart).as_secs_f64() * 1000.0
        );
        total_time_meshing += mend.duration_since(mstart).as_secs_f64();
        // v.push(format!("{:?}", vertices).to_string());
        for (vx, vy, vz) in &vertices {
            v.push(format!("v {} {} {}\n", base.0 + vx, vy, base.1 + vz));
        }

        for index in indices.chunks(4) {
            v.push(format!(
                "f {} {} {} {}\n",
                base_index + index[0],
                base_index + index[1],
                base_index + index[2],
                base_index + index[3]
            ));
        }
        base_index += vertices.len() as u32;
        // let heightmap = c.generate_heightmap();
        // for x in 0..16 {
        //     for z in 0..16 {
        //         let y = heightmap[(z << 4) | x];
        //         v.push(
        //             format_args!(
        //                 "v {} {} {}\n",
        //                 base.0 + x as f32,
        //                 y as f32,
        //                 base.1 + z as f32
        //             )
        //             .to_string(),
        //         );
        //     }
        // }
        // for x in 0..16 {
        //     for z in 0..16 {
        //         for y in 0..256 {
        //             let block = c.get_block(x, y, z);
        //             if block != 0 && !c.is_block_obstructed(x, y, z) {
        //                 v.push(
        //                     format_args!(
        //                         "v {} {} {}\n",
        //                         base.0 + x as f32,
        //                         y as f32,
        //                         base.1 + z as f32
        //                     )
        //                     .to_string(),
        //                 );
        //                 // objf.write_fmt(format_args!(
        //                 //     "v {} {} {}\n",
        //                 //     base.0 + x as f32,
        //                 //     y as f32,
        //                 //     base.1 + z as f32
        //                 // ))?;
        //             }
        //         }
        //     }
        // }
    }

    println!(
        "Meshing took {}ms, averaging at {}ms per chunk",
        total_time_meshing * 1000.0,
        (total_time_meshing / chunks.chunks.len() as f64) * 1000.0
    );

    let mut big_string = String::with_capacity(v.len() * 16);
    for si in v {
        big_string += &si;
        // objf.write_all(si.as_bytes())?;
    }

    objf.write_all(big_string.as_bytes())?;

    Ok(())
}
